<?php
namespace Tests\Request;

use PHPUnit\Framework\TestCase;
use Veles\Request\HttpJsonRequest;
use Veles\Request\Validator\Validator;
use Veles\Exceptions\Http\UnprocessableException;

/**
 * Generated by PHPUnit_SkeletonGenerator on 2017-01-29 at 21:29:45.
 * @group request
 */
class HttpJsonRequestTest extends TestCase
{
	/**
	 * @var HttpJsonRequest
	 */
	protected $object;

	/**
	 * Sets up the fixture, for example, opens a network connection.
	 * This method is called before a test is executed.
	 */
	protected function setUp(): void
	{
		$this->object = new HttpJsonRequest;
	}

	public function testGetBody(): void
	{
		$filename = uniqid() . '.txt';
		$json = '{"message": "this is text"}';
		$expected = ['message' => 'this is text'];

		file_put_contents($filename, $json);
		$this->object->setStream($filename);

		$result = $this->object->getBody();
		unlink($filename);

		$msg = 'HttpJsonRequest::getBody() returns wrong result!';
		self::assertEquals($expected, $result, $msg);
	}

	public function testCheck()
	{
		$definitions = [
			'message' => [
				'filter'  => FILTER_VALIDATE_REGEXP,
				'flag'    => FILTER_REQUIRE_SCALAR,
				'options' => [
					'regexp'   => '/^this is tests string$/'
				]
			],
			'value' => [
				'filter'  => FILTER_VALIDATE_INT,
				'flag'    => FILTER_REQUIRE_SCALAR,
				'options' => [
					'min_range' => 1,
					'max_range' => PHP_INT_MAX
				]
			]
		];
		$json = '{"message": "this is tests string", "value": 1234}';
		$expected = ['message' => 'this is tests string', 'value' => 1234];

		$this->object = $this->getMockBuilder(HttpJsonRequest::class)
			->onlyMethods(['getBody'])
			->getMock();

		$this->object->expects(self::once())
			->method('getBody')
			->willReturn(json_decode($json, true));

		$validator = $this->getMockBuilder(Validator::class)
			->onlyMethods(['check', 'isValid'])
			->getMock();

		$validator->expects(self::once())
			->method('check')
			->with(json_decode($json, true), $definitions);

		$validator->expects(self::once())
			->method('isValid')
			->willReturn(true);

		$this->object->setValidator($validator);

		$this->object->check($definitions);
	}

	public function testCheckException(): void
	{
		$this->expectException(UnprocessableException::class);

		$definitions = [
			'message' => [
				'filter'  => FILTER_VALIDATE_REGEXP,
				'flag'    => FILTER_REQUIRE_SCALAR,
				'options' => [
					'regexp'   => '/^this is tests string$/'
				]
			]
		];

		$errors = ['ERROR_MSG'];
		$json   = '{"message": "this is tests string"}';

		$this->object = $this->getMockBuilder(HttpJsonRequest::class)
			->onlyMethods(['getBody'])
			->getMock();

		$this->object->expects(self::once())
			->method('getBody')
			->willReturn(json_decode($json, true));

		$validator = $this->getMockBuilder(Validator::class)
			->onlyMethods(['check', 'isValid', 'getErrors'])
			->getMock();

		$validator->expects(self::once())
			->method('check')
			->with(json_decode($json, true), $definitions);

		$validator->expects(self::once())
			->method('isValid')
			->willReturn(false);

		$validator->expects(self::once())
			->method('getErrors')
			->willReturn($errors);

		$this->object->setValidator($validator);
		$this->expectOutputString('{"errors":["ERROR_MSG"]}');

		$this->object->check($definitions);
	}
}
